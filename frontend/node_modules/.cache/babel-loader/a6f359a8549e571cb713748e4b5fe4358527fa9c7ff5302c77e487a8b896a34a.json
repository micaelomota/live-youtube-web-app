{"ast":null,"code":"\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect } from 'react';\nimport { useMutateObserver } from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport { useToken } from '../theme/internal';\nimport WatermarkContext from './context';\nimport useClips, { FontGap } from './useClips';\nimport useRafDebounce from './useRafDebounce';\nimport useWatermark from './useWatermark';\nimport { getPixelRatio, reRendering } from './utils';\n/**\n * Only return `next` when size changed.\n * This is only used for elements compare, not a shallow equal!\n */\nfunction getSizeDiff(prev, next) {\n  return prev.size === next.size ? prev : next;\n}\nconst DEFAULT_GAP_X = 100;\nconst DEFAULT_GAP_Y = 100;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],\n    offset,\n    children,\n    inherit = true\n  } = props;\n  const [, token] = useToken();\n  const {\n    color = token.colorFill,\n    fontSize = token.fontSizeLG,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif',\n    textAlign = 'center'\n  } = font;\n  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const markStyle = React.useMemo(() => {\n    const mergedStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      mergedStyle.left = `${positionLeft}px`;\n      mergedStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      mergedStyle.top = `${positionTop}px`;\n      mergedStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    mergedStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return mergedStyle;\n  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);\n  const [container, setContainer] = React.useState();\n  // Used for nest case like Modal, Drawer\n  const [subElements, setSubElements] = React.useState(new Set());\n  // Nest elements should also support watermark\n  const targetElements = React.useMemo(() => {\n    const list = container ? [container] : [];\n    return [].concat(list, _toConsumableArray(Array.from(subElements)));\n  }, [container, subElements]);\n  // ============================ Content =============================\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const sizes = contents.map(item => {\n        const metrics = ctx.measureText(item);\n        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n      });\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[0]))));\n      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[1])))) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const getClips = useClips();\n  const [watermarkInfo, setWatermarkInfo] = React.useState(null);\n  // Generate new Watermark content\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const drawCanvas = drawContent => {\n        const [nextClips, clipWidth] = getClips(drawContent || '', rotate, ratio, markWidth, markHeight, {\n          color,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          fontFamily,\n          textAlign\n        }, gapX, gapY);\n        setWatermarkInfo([nextClips, clipWidth]);\n      };\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          drawCanvas(img);\n        };\n        img.onerror = () => {\n          drawCanvas(content);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n  const syncWatermark = useRafDebounce(renderWatermark);\n  // ============================= Effect =============================\n  // Append watermark to the container\n  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);\n  useEffect(() => {\n    if (watermarkInfo) {\n      targetElements.forEach(holder => {\n        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);\n      });\n    }\n  }, [watermarkInfo, targetElements]);\n  // ============================ Observe =============================\n  const onMutate = mutations => {\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, isWatermarkEle)) {\n        syncWatermark();\n      }\n    });\n  };\n  useMutateObserver(targetElements, onMutate);\n  useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);\n  // ============================ Context =============================\n  const watermarkContext = React.useMemo(() => ({\n    add: ele => {\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.add(ele);\n        return getSizeDiff(prev, clone);\n      });\n    },\n    remove: ele => {\n      removeWatermark(ele);\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.delete(ele);\n        return getSizeDiff(prev, clone);\n      });\n    }\n  }), []);\n  // ============================= Render =============================\n  const childNode = inherit ? ( /*#__PURE__*/React.createElement(WatermarkContext.Provider, {\n    value: watermarkContext\n  }, children)) : children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: setContainer,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, childNode);\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;","map":{"version":3,"names":["_toConsumableArray","React","useEffect","useMutateObserver","classNames","useToken","WatermarkContext","useClips","FontGap","useRafDebounce","useWatermark","getPixelRatio","reRendering","getSizeDiff","prev","next","size","DEFAULT_GAP_X","DEFAULT_GAP_Y","Watermark","props","_a","_b","zIndex","rotate","width","height","image","content","font","style","className","rootClassName","gap","offset","children","inherit","token","color","colorFill","fontSize","fontSizeLG","fontWeight","fontStyle","fontFamily","textAlign","gapX","gapY","gapXCenter","gapYCenter","offsetLeft","offsetTop","markStyle","useMemo","mergedStyle","position","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","container","setContainer","useState","subElements","setSubElements","Set","targetElements","list","concat","Array","from","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","Number","contents","isArray","sizes","map","item","metrics","fontBoundingBoxAscent","fontBoundingBoxDescent","Math","ceil","max","apply","length","getClips","watermarkInfo","setWatermarkInfo","renderWatermark","canvas","document","createElement","getContext","ratio","markWidth","markHeight","drawCanvas","drawContent","nextClips","clipWidth","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","syncWatermark","appendWatermark","removeWatermark","isWatermarkEle","forEach","holder","onMutate","mutations","mutation","watermarkContext","add","ele","clone","remove","delete","childNode","Provider","value","ref","Object","assign","process","env","NODE_ENV","displayName"],"sources":["/home/jp/Documentos/Projects/open-source/live-youtube-web-app/frontend/node_modules/antd/es/watermark/index.js"],"sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect } from 'react';\nimport { useMutateObserver } from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport { useToken } from '../theme/internal';\nimport WatermarkContext from './context';\nimport useClips, { FontGap } from './useClips';\nimport useRafDebounce from './useRafDebounce';\nimport useWatermark from './useWatermark';\nimport { getPixelRatio, reRendering } from './utils';\n/**\n * Only return `next` when size changed.\n * This is only used for elements compare, not a shallow equal!\n */\nfunction getSizeDiff(prev, next) {\n  return prev.size === next.size ? prev : next;\n}\nconst DEFAULT_GAP_X = 100;\nconst DEFAULT_GAP_Y = 100;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],\n    offset,\n    children,\n    inherit = true\n  } = props;\n  const [, token] = useToken();\n  const {\n    color = token.colorFill,\n    fontSize = token.fontSizeLG,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif',\n    textAlign = 'center'\n  } = font;\n  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const markStyle = React.useMemo(() => {\n    const mergedStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      mergedStyle.left = `${positionLeft}px`;\n      mergedStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      mergedStyle.top = `${positionTop}px`;\n      mergedStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    mergedStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return mergedStyle;\n  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);\n  const [container, setContainer] = React.useState();\n  // Used for nest case like Modal, Drawer\n  const [subElements, setSubElements] = React.useState(new Set());\n  // Nest elements should also support watermark\n  const targetElements = React.useMemo(() => {\n    const list = container ? [container] : [];\n    return [].concat(list, _toConsumableArray(Array.from(subElements)));\n  }, [container, subElements]);\n  // ============================ Content =============================\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const sizes = contents.map(item => {\n        const metrics = ctx.measureText(item);\n        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n      });\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[0]))));\n      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[1])))) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const getClips = useClips();\n  const [watermarkInfo, setWatermarkInfo] = React.useState(null);\n  // Generate new Watermark content\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const drawCanvas = drawContent => {\n        const [nextClips, clipWidth] = getClips(drawContent || '', rotate, ratio, markWidth, markHeight, {\n          color,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          fontFamily,\n          textAlign\n        }, gapX, gapY);\n        setWatermarkInfo([nextClips, clipWidth]);\n      };\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          drawCanvas(img);\n        };\n        img.onerror = () => {\n          drawCanvas(content);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n  const syncWatermark = useRafDebounce(renderWatermark);\n  // ============================= Effect =============================\n  // Append watermark to the container\n  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);\n  useEffect(() => {\n    if (watermarkInfo) {\n      targetElements.forEach(holder => {\n        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);\n      });\n    }\n  }, [watermarkInfo, targetElements]);\n  // ============================ Observe =============================\n  const onMutate = mutations => {\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, isWatermarkEle)) {\n        syncWatermark();\n      }\n    });\n  };\n  useMutateObserver(targetElements, onMutate);\n  useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);\n  // ============================ Context =============================\n  const watermarkContext = React.useMemo(() => ({\n    add: ele => {\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.add(ele);\n        return getSizeDiff(prev, clone);\n      });\n    },\n    remove: ele => {\n      removeWatermark(ele);\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.delete(ele);\n        return getSizeDiff(prev, clone);\n      });\n    }\n  }), []);\n  // ============================= Render =============================\n  const childNode = inherit ? ( /*#__PURE__*/React.createElement(WatermarkContext.Provider, {\n    value: watermarkContext\n  }, children)) : children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: setContainer,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, childNode);\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;"],"mappings":"AAAA,YAAY;;AAEZ,OAAOA,kBAAkB,MAAM,8CAA8C;AAC7E,OAAOC,KAAK,IAAIC,SAAS,QAAQ,OAAO;AACxC,SAASC,iBAAiB,QAAQ,+BAA+B;AACjE,OAAOC,UAAU,MAAM,YAAY;AACnC,SAASC,QAAQ,QAAQ,mBAAmB;AAC5C,OAAOC,gBAAgB,MAAM,WAAW;AACxC,OAAOC,QAAQ,IAAIC,OAAO,QAAQ,YAAY;AAC9C,OAAOC,cAAc,MAAM,kBAAkB;AAC7C,OAAOC,YAAY,MAAM,gBAAgB;AACzC,SAASC,aAAa,EAAEC,WAAW,QAAQ,SAAS;AACpD;AACA;AACA;AACA;AACA,SAASC,WAAWA,CAACC,IAAI,EAAEC,IAAI,EAAE;EAC/B,OAAOD,IAAI,CAACE,IAAI,KAAKD,IAAI,CAACC,IAAI,GAAGF,IAAI,GAAGC,IAAI;AAC9C;AACA,MAAME,aAAa,GAAG,GAAG;AACzB,MAAMC,aAAa,GAAG,GAAG;AACzB,MAAMC,SAAS,GAAGC,KAAK,IAAI;EACzB,IAAIC,EAAE,EAAEC,EAAE;EACV,MAAM;IACJ;AACJ;AACA;AACA;IACIC,MAAM,GAAG,CAAC;IACVC,MAAM,GAAG,CAAC,EAAE;IACZC,KAAK;IACLC,MAAM;IACNC,KAAK;IACLC,OAAO;IACPC,IAAI,GAAG,CAAC,CAAC;IACTC,KAAK;IACLC,SAAS;IACTC,aAAa;IACbC,GAAG,GAAG,CAAChB,aAAa,EAAEC,aAAa,CAAC;IACpCgB,MAAM;IACNC,QAAQ;IACRC,OAAO,GAAG;EACZ,CAAC,GAAGhB,KAAK;EACT,MAAM,GAAGiB,KAAK,CAAC,GAAGhC,QAAQ,CAAC,CAAC;EAC5B,MAAM;IACJiC,KAAK,GAAGD,KAAK,CAACE,SAAS;IACvBC,QAAQ,GAAGH,KAAK,CAACI,UAAU;IAC3BC,UAAU,GAAG,QAAQ;IACrBC,SAAS,GAAG,QAAQ;IACpBC,UAAU,GAAG,YAAY;IACzBC,SAAS,GAAG;EACd,CAAC,GAAGhB,IAAI;EACR,MAAM,CAACiB,IAAI,GAAG7B,aAAa,EAAE8B,IAAI,GAAG7B,aAAa,CAAC,GAAGe,GAAG;EACxD,MAAMe,UAAU,GAAGF,IAAI,GAAG,CAAC;EAC3B,MAAMG,UAAU,GAAGF,IAAI,GAAG,CAAC;EAC3B,MAAMG,UAAU,GAAG,CAAC7B,EAAE,GAAGa,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIb,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG2B,UAAU;EAC/H,MAAMG,SAAS,GAAG,CAAC7B,EAAE,GAAGY,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIZ,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG2B,UAAU;EAC9H,MAAMG,SAAS,GAAGnD,KAAK,CAACoD,OAAO,CAAC,MAAM;IACpC,MAAMC,WAAW,GAAG;MAClB/B,MAAM;MACNgC,QAAQ,EAAE,UAAU;MACpBC,IAAI,EAAE,CAAC;MACPC,GAAG,EAAE,CAAC;MACNhC,KAAK,EAAE,MAAM;MACbC,MAAM,EAAE,MAAM;MACdgC,aAAa,EAAE,MAAM;MACrBC,gBAAgB,EAAE;IACpB,CAAC;IACD;IACA,IAAIC,YAAY,GAAGV,UAAU,GAAGF,UAAU;IAC1C,IAAIa,WAAW,GAAGV,SAAS,GAAGF,UAAU;IACxC,IAAIW,YAAY,GAAG,CAAC,EAAE;MACpBN,WAAW,CAACE,IAAI,GAAI,GAAEI,YAAa,IAAG;MACtCN,WAAW,CAAC7B,KAAK,GAAI,eAAcmC,YAAa,KAAI;MACpDA,YAAY,GAAG,CAAC;IAClB;IACA,IAAIC,WAAW,GAAG,CAAC,EAAE;MACnBP,WAAW,CAACG,GAAG,GAAI,GAAEI,WAAY,IAAG;MACpCP,WAAW,CAAC5B,MAAM,GAAI,eAAcmC,WAAY,KAAI;MACpDA,WAAW,GAAG,CAAC;IACjB;IACAP,WAAW,CAACQ,kBAAkB,GAAI,GAAEF,YAAa,MAAKC,WAAY,IAAG;IACrE,OAAOP,WAAW;EACpB,CAAC,EAAE,CAAC/B,MAAM,EAAE2B,UAAU,EAAEF,UAAU,EAAEG,SAAS,EAAEF,UAAU,CAAC,CAAC;EAC3D,MAAM,CAACc,SAAS,EAAEC,YAAY,CAAC,GAAG/D,KAAK,CAACgE,QAAQ,CAAC,CAAC;EAClD;EACA,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGlE,KAAK,CAACgE,QAAQ,CAAC,IAAIG,GAAG,CAAC,CAAC,CAAC;EAC/D;EACA,MAAMC,cAAc,GAAGpE,KAAK,CAACoD,OAAO,CAAC,MAAM;IACzC,MAAMiB,IAAI,GAAGP,SAAS,GAAG,CAACA,SAAS,CAAC,GAAG,EAAE;IACzC,OAAO,EAAE,CAACQ,MAAM,CAACD,IAAI,EAAEtE,kBAAkB,CAACwE,KAAK,CAACC,IAAI,CAACP,WAAW,CAAC,CAAC,CAAC;EACrE,CAAC,EAAE,CAACH,SAAS,EAAEG,WAAW,CAAC,CAAC;EAC5B;EACA;AACF;AACA;AACA;EACE,MAAMQ,WAAW,GAAGC,GAAG,IAAI;IACzB,IAAIC,YAAY,GAAG,GAAG;IACtB,IAAIC,aAAa,GAAG,EAAE;IACtB,IAAI,CAAClD,KAAK,IAAIgD,GAAG,CAACG,WAAW,EAAE;MAC7BH,GAAG,CAAC9C,IAAI,GAAI,GAAEkD,MAAM,CAACvC,QAAQ,CAAE,MAAKI,UAAW,EAAC;MAChD,MAAMoC,QAAQ,GAAGR,KAAK,CAACS,OAAO,CAACrD,OAAO,CAAC,GAAGA,OAAO,GAAG,CAACA,OAAO,CAAC;MAC7D,MAAMsD,KAAK,GAAGF,QAAQ,CAACG,GAAG,CAACC,IAAI,IAAI;QACjC,MAAMC,OAAO,GAAGV,GAAG,CAACG,WAAW,CAACM,IAAI,CAAC;QACrC,OAAO,CAACC,OAAO,CAAC5D,KAAK,EAAE4D,OAAO,CAACC,qBAAqB,GAAGD,OAAO,CAACE,sBAAsB,CAAC;MACxF,CAAC,CAAC;MACFX,YAAY,GAAGY,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACC,KAAK,CAACH,IAAI,EAAExF,kBAAkB,CAACkF,KAAK,CAACC,GAAG,CAACnE,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MAC9F6D,aAAa,GAAGW,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACC,KAAK,CAACH,IAAI,EAAExF,kBAAkB,CAACkF,KAAK,CAACC,GAAG,CAACnE,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGgE,QAAQ,CAACY,MAAM,GAAG,CAACZ,QAAQ,CAACY,MAAM,GAAG,CAAC,IAAIpF,OAAO;IACrJ;IACA,OAAO,CAACiB,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAGA,KAAK,GAAGmD,YAAY,EAAElD,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAGA,MAAM,GAAGmD,aAAa,CAAC;EACnI,CAAC;EACD,MAAMgB,QAAQ,GAAGtF,QAAQ,CAAC,CAAC;EAC3B,MAAM,CAACuF,aAAa,EAAEC,gBAAgB,CAAC,GAAG9F,KAAK,CAACgE,QAAQ,CAAC,IAAI,CAAC;EAC9D;EACA,MAAM+B,eAAe,GAAGA,CAAA,KAAM;IAC5B,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IAC/C,MAAMxB,GAAG,GAAGsB,MAAM,CAACG,UAAU,CAAC,IAAI,CAAC;IACnC,IAAIzB,GAAG,EAAE;MACP,MAAM0B,KAAK,GAAG1F,aAAa,CAAC,CAAC;MAC7B,MAAM,CAAC2F,SAAS,EAAEC,UAAU,CAAC,GAAG7B,WAAW,CAACC,GAAG,CAAC;MAChD,MAAM6B,UAAU,GAAGC,WAAW,IAAI;QAChC,MAAM,CAACC,SAAS,EAAEC,SAAS,CAAC,GAAGd,QAAQ,CAACY,WAAW,IAAI,EAAE,EAAEjF,MAAM,EAAE6E,KAAK,EAAEC,SAAS,EAAEC,UAAU,EAAE;UAC/FjE,KAAK;UACLE,QAAQ;UACRG,SAAS;UACTD,UAAU;UACVE,UAAU;UACVC;QACF,CAAC,EAAEC,IAAI,EAAEC,IAAI,CAAC;QACdgD,gBAAgB,CAAC,CAACW,SAAS,EAAEC,SAAS,CAAC,CAAC;MAC1C,CAAC;MACD,IAAIhF,KAAK,EAAE;QACT,MAAMiF,GAAG,GAAG,IAAIC,KAAK,CAAC,CAAC;QACvBD,GAAG,CAACE,MAAM,GAAG,MAAM;UACjBN,UAAU,CAACI,GAAG,CAAC;QACjB,CAAC;QACDA,GAAG,CAACG,OAAO,GAAG,MAAM;UAClBP,UAAU,CAAC5E,OAAO,CAAC;QACrB,CAAC;QACDgF,GAAG,CAACI,WAAW,GAAG,WAAW;QAC7BJ,GAAG,CAACK,cAAc,GAAG,aAAa;QAClCL,GAAG,CAACM,GAAG,GAAGvF,KAAK;MACjB,CAAC,MAAM;QACL6E,UAAU,CAAC5E,OAAO,CAAC;MACrB;IACF;EACF,CAAC;EACD,MAAMuF,aAAa,GAAG1G,cAAc,CAACuF,eAAe,CAAC;EACrD;EACA;EACA,MAAM,CAACoB,eAAe,EAAEC,eAAe,EAAEC,cAAc,CAAC,GAAG5G,YAAY,CAAC0C,SAAS,CAAC;EAClFlD,SAAS,CAAC,MAAM;IACd,IAAI4F,aAAa,EAAE;MACjBzB,cAAc,CAACkD,OAAO,CAACC,MAAM,IAAI;QAC/BJ,eAAe,CAACtB,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC,CAAC,CAAC,EAAE0B,MAAM,CAAC;MAC7D,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAAC1B,aAAa,EAAEzB,cAAc,CAAC,CAAC;EACnC;EACA,MAAMoD,QAAQ,GAAGC,SAAS,IAAI;IAC5BA,SAAS,CAACH,OAAO,CAACI,QAAQ,IAAI;MAC5B,IAAI/G,WAAW,CAAC+G,QAAQ,EAAEL,cAAc,CAAC,EAAE;QACzCH,aAAa,CAAC,CAAC;MACjB;IACF,CAAC,CAAC;EACJ,CAAC;EACDhH,iBAAiB,CAACkE,cAAc,EAAEoD,QAAQ,CAAC;EAC3CvH,SAAS,CAACiH,aAAa,EAAE,CAAC3F,MAAM,EAAED,MAAM,EAAEE,KAAK,EAAEC,MAAM,EAAEC,KAAK,EAAEC,OAAO,EAAEU,KAAK,EAAEE,QAAQ,EAAEE,UAAU,EAAEC,SAAS,EAAEC,UAAU,EAAEC,SAAS,EAAEC,IAAI,EAAEC,IAAI,EAAEG,UAAU,EAAEC,SAAS,CAAC,CAAC;EAC3K;EACA,MAAMyE,gBAAgB,GAAG3H,KAAK,CAACoD,OAAO,CAAC,OAAO;IAC5CwE,GAAG,EAAEC,GAAG,IAAI;MACV3D,cAAc,CAACrD,IAAI,IAAI;QACrB,MAAMiH,KAAK,GAAG,IAAI3D,GAAG,CAACtD,IAAI,CAAC;QAC3BiH,KAAK,CAACF,GAAG,CAACC,GAAG,CAAC;QACd,OAAOjH,WAAW,CAACC,IAAI,EAAEiH,KAAK,CAAC;MACjC,CAAC,CAAC;IACJ,CAAC;IACDC,MAAM,EAAEF,GAAG,IAAI;MACbT,eAAe,CAACS,GAAG,CAAC;MACpB3D,cAAc,CAACrD,IAAI,IAAI;QACrB,MAAMiH,KAAK,GAAG,IAAI3D,GAAG,CAACtD,IAAI,CAAC;QAC3BiH,KAAK,CAACE,MAAM,CAACH,GAAG,CAAC;QACjB,OAAOjH,WAAW,CAACC,IAAI,EAAEiH,KAAK,CAAC;MACjC,CAAC,CAAC;IACJ;EACF,CAAC,CAAC,EAAE,EAAE,CAAC;EACP;EACA,MAAMG,SAAS,GAAG9F,OAAO,KAAK,aAAanC,KAAK,CAACkG,aAAa,CAAC7F,gBAAgB,CAAC6H,QAAQ,EAAE;IACxFC,KAAK,EAAER;EACT,CAAC,EAAEzF,QAAQ,CAAC,IAAIA,QAAQ;EACxB,OAAO,aAAalC,KAAK,CAACkG,aAAa,CAAC,KAAK,EAAE;IAC7CkC,GAAG,EAAErE,YAAY;IACjBjC,SAAS,EAAE3B,UAAU,CAAC2B,SAAS,EAAEC,aAAa,CAAC;IAC/CF,KAAK,EAAEwG,MAAM,CAACC,MAAM,CAAC;MACnBhF,QAAQ,EAAE;IACZ,CAAC,EAAEzB,KAAK;EACV,CAAC,EAAEoG,SAAS,CAAC;AACf,CAAC;AACD,IAAIM,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;EACzCvH,SAAS,CAACwH,WAAW,GAAG,WAAW;AACrC;AACA,eAAexH,SAAS"},"metadata":{},"sourceType":"module","externalDependencies":[]}